// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'symbol.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$SymbolTearOff {
  const _$SymbolTearOff();

  Bell bell() {
    return const Bell();
  }

  Bar bar() {
    return const Bar();
  }

  Cherry cherry() {
    return const Cherry();
  }

  Plum plum() {
    return const Plum();
  }

  Replay replay() {
    return const Replay();
  }

  Seven seven() {
    return const Seven();
  }

  Watermelon watermelon() {
    return const Watermelon();
  }
}

/// @nodoc
const $Symbol = _$SymbolTearOff();

/// @nodoc
mixin _$Symbol {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() bell,
    required TResult Function() bar,
    required TResult Function() cherry,
    required TResult Function() plum,
    required TResult Function() replay,
    required TResult Function() seven,
    required TResult Function() watermelon,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? bell,
    TResult Function()? bar,
    TResult Function()? cherry,
    TResult Function()? plum,
    TResult Function()? replay,
    TResult Function()? seven,
    TResult Function()? watermelon,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bell value) bell,
    required TResult Function(Bar value) bar,
    required TResult Function(Cherry value) cherry,
    required TResult Function(Plum value) plum,
    required TResult Function(Replay value) replay,
    required TResult Function(Seven value) seven,
    required TResult Function(Watermelon value) watermelon,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bell value)? bell,
    TResult Function(Bar value)? bar,
    TResult Function(Cherry value)? cherry,
    TResult Function(Plum value)? plum,
    TResult Function(Replay value)? replay,
    TResult Function(Seven value)? seven,
    TResult Function(Watermelon value)? watermelon,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SymbolCopyWith<$Res> {
  factory $SymbolCopyWith(Symbol value, $Res Function(Symbol) then) =
      _$SymbolCopyWithImpl<$Res>;
}

/// @nodoc
class _$SymbolCopyWithImpl<$Res> implements $SymbolCopyWith<$Res> {
  _$SymbolCopyWithImpl(this._value, this._then);

  final Symbol _value;
  // ignore: unused_field
  final $Res Function(Symbol) _then;
}

/// @nodoc
abstract class $BellCopyWith<$Res> {
  factory $BellCopyWith(Bell value, $Res Function(Bell) then) =
      _$BellCopyWithImpl<$Res>;
}

/// @nodoc
class _$BellCopyWithImpl<$Res> extends _$SymbolCopyWithImpl<$Res>
    implements $BellCopyWith<$Res> {
  _$BellCopyWithImpl(Bell _value, $Res Function(Bell) _then)
      : super(_value, (v) => _then(v as Bell));

  @override
  Bell get _value => super._value as Bell;
}

/// @nodoc

class _$Bell implements Bell {
  const _$Bell();

  @override
  String toString() {
    return 'Symbol.bell()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Bell);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() bell,
    required TResult Function() bar,
    required TResult Function() cherry,
    required TResult Function() plum,
    required TResult Function() replay,
    required TResult Function() seven,
    required TResult Function() watermelon,
  }) {
    return bell();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? bell,
    TResult Function()? bar,
    TResult Function()? cherry,
    TResult Function()? plum,
    TResult Function()? replay,
    TResult Function()? seven,
    TResult Function()? watermelon,
    required TResult orElse(),
  }) {
    if (bell != null) {
      return bell();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bell value) bell,
    required TResult Function(Bar value) bar,
    required TResult Function(Cherry value) cherry,
    required TResult Function(Plum value) plum,
    required TResult Function(Replay value) replay,
    required TResult Function(Seven value) seven,
    required TResult Function(Watermelon value) watermelon,
  }) {
    return bell(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bell value)? bell,
    TResult Function(Bar value)? bar,
    TResult Function(Cherry value)? cherry,
    TResult Function(Plum value)? plum,
    TResult Function(Replay value)? replay,
    TResult Function(Seven value)? seven,
    TResult Function(Watermelon value)? watermelon,
    required TResult orElse(),
  }) {
    if (bell != null) {
      return bell(this);
    }
    return orElse();
  }
}

abstract class Bell implements Symbol {
  const factory Bell() = _$Bell;
}

/// @nodoc
abstract class $BarCopyWith<$Res> {
  factory $BarCopyWith(Bar value, $Res Function(Bar) then) =
      _$BarCopyWithImpl<$Res>;
}

/// @nodoc
class _$BarCopyWithImpl<$Res> extends _$SymbolCopyWithImpl<$Res>
    implements $BarCopyWith<$Res> {
  _$BarCopyWithImpl(Bar _value, $Res Function(Bar) _then)
      : super(_value, (v) => _then(v as Bar));

  @override
  Bar get _value => super._value as Bar;
}

/// @nodoc

class _$Bar implements Bar {
  const _$Bar();

  @override
  String toString() {
    return 'Symbol.bar()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Bar);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() bell,
    required TResult Function() bar,
    required TResult Function() cherry,
    required TResult Function() plum,
    required TResult Function() replay,
    required TResult Function() seven,
    required TResult Function() watermelon,
  }) {
    return bar();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? bell,
    TResult Function()? bar,
    TResult Function()? cherry,
    TResult Function()? plum,
    TResult Function()? replay,
    TResult Function()? seven,
    TResult Function()? watermelon,
    required TResult orElse(),
  }) {
    if (bar != null) {
      return bar();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bell value) bell,
    required TResult Function(Bar value) bar,
    required TResult Function(Cherry value) cherry,
    required TResult Function(Plum value) plum,
    required TResult Function(Replay value) replay,
    required TResult Function(Seven value) seven,
    required TResult Function(Watermelon value) watermelon,
  }) {
    return bar(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bell value)? bell,
    TResult Function(Bar value)? bar,
    TResult Function(Cherry value)? cherry,
    TResult Function(Plum value)? plum,
    TResult Function(Replay value)? replay,
    TResult Function(Seven value)? seven,
    TResult Function(Watermelon value)? watermelon,
    required TResult orElse(),
  }) {
    if (bar != null) {
      return bar(this);
    }
    return orElse();
  }
}

abstract class Bar implements Symbol {
  const factory Bar() = _$Bar;
}

/// @nodoc
abstract class $CherryCopyWith<$Res> {
  factory $CherryCopyWith(Cherry value, $Res Function(Cherry) then) =
      _$CherryCopyWithImpl<$Res>;
}

/// @nodoc
class _$CherryCopyWithImpl<$Res> extends _$SymbolCopyWithImpl<$Res>
    implements $CherryCopyWith<$Res> {
  _$CherryCopyWithImpl(Cherry _value, $Res Function(Cherry) _then)
      : super(_value, (v) => _then(v as Cherry));

  @override
  Cherry get _value => super._value as Cherry;
}

/// @nodoc

class _$Cherry implements Cherry {
  const _$Cherry();

  @override
  String toString() {
    return 'Symbol.cherry()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Cherry);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() bell,
    required TResult Function() bar,
    required TResult Function() cherry,
    required TResult Function() plum,
    required TResult Function() replay,
    required TResult Function() seven,
    required TResult Function() watermelon,
  }) {
    return cherry();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? bell,
    TResult Function()? bar,
    TResult Function()? cherry,
    TResult Function()? plum,
    TResult Function()? replay,
    TResult Function()? seven,
    TResult Function()? watermelon,
    required TResult orElse(),
  }) {
    if (cherry != null) {
      return cherry();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bell value) bell,
    required TResult Function(Bar value) bar,
    required TResult Function(Cherry value) cherry,
    required TResult Function(Plum value) plum,
    required TResult Function(Replay value) replay,
    required TResult Function(Seven value) seven,
    required TResult Function(Watermelon value) watermelon,
  }) {
    return cherry(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bell value)? bell,
    TResult Function(Bar value)? bar,
    TResult Function(Cherry value)? cherry,
    TResult Function(Plum value)? plum,
    TResult Function(Replay value)? replay,
    TResult Function(Seven value)? seven,
    TResult Function(Watermelon value)? watermelon,
    required TResult orElse(),
  }) {
    if (cherry != null) {
      return cherry(this);
    }
    return orElse();
  }
}

abstract class Cherry implements Symbol {
  const factory Cherry() = _$Cherry;
}

/// @nodoc
abstract class $PlumCopyWith<$Res> {
  factory $PlumCopyWith(Plum value, $Res Function(Plum) then) =
      _$PlumCopyWithImpl<$Res>;
}

/// @nodoc
class _$PlumCopyWithImpl<$Res> extends _$SymbolCopyWithImpl<$Res>
    implements $PlumCopyWith<$Res> {
  _$PlumCopyWithImpl(Plum _value, $Res Function(Plum) _then)
      : super(_value, (v) => _then(v as Plum));

  @override
  Plum get _value => super._value as Plum;
}

/// @nodoc

class _$Plum implements Plum {
  const _$Plum();

  @override
  String toString() {
    return 'Symbol.plum()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Plum);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() bell,
    required TResult Function() bar,
    required TResult Function() cherry,
    required TResult Function() plum,
    required TResult Function() replay,
    required TResult Function() seven,
    required TResult Function() watermelon,
  }) {
    return plum();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? bell,
    TResult Function()? bar,
    TResult Function()? cherry,
    TResult Function()? plum,
    TResult Function()? replay,
    TResult Function()? seven,
    TResult Function()? watermelon,
    required TResult orElse(),
  }) {
    if (plum != null) {
      return plum();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bell value) bell,
    required TResult Function(Bar value) bar,
    required TResult Function(Cherry value) cherry,
    required TResult Function(Plum value) plum,
    required TResult Function(Replay value) replay,
    required TResult Function(Seven value) seven,
    required TResult Function(Watermelon value) watermelon,
  }) {
    return plum(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bell value)? bell,
    TResult Function(Bar value)? bar,
    TResult Function(Cherry value)? cherry,
    TResult Function(Plum value)? plum,
    TResult Function(Replay value)? replay,
    TResult Function(Seven value)? seven,
    TResult Function(Watermelon value)? watermelon,
    required TResult orElse(),
  }) {
    if (plum != null) {
      return plum(this);
    }
    return orElse();
  }
}

abstract class Plum implements Symbol {
  const factory Plum() = _$Plum;
}

/// @nodoc
abstract class $ReplayCopyWith<$Res> {
  factory $ReplayCopyWith(Replay value, $Res Function(Replay) then) =
      _$ReplayCopyWithImpl<$Res>;
}

/// @nodoc
class _$ReplayCopyWithImpl<$Res> extends _$SymbolCopyWithImpl<$Res>
    implements $ReplayCopyWith<$Res> {
  _$ReplayCopyWithImpl(Replay _value, $Res Function(Replay) _then)
      : super(_value, (v) => _then(v as Replay));

  @override
  Replay get _value => super._value as Replay;
}

/// @nodoc

class _$Replay implements Replay {
  const _$Replay();

  @override
  String toString() {
    return 'Symbol.replay()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Replay);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() bell,
    required TResult Function() bar,
    required TResult Function() cherry,
    required TResult Function() plum,
    required TResult Function() replay,
    required TResult Function() seven,
    required TResult Function() watermelon,
  }) {
    return replay();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? bell,
    TResult Function()? bar,
    TResult Function()? cherry,
    TResult Function()? plum,
    TResult Function()? replay,
    TResult Function()? seven,
    TResult Function()? watermelon,
    required TResult orElse(),
  }) {
    if (replay != null) {
      return replay();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bell value) bell,
    required TResult Function(Bar value) bar,
    required TResult Function(Cherry value) cherry,
    required TResult Function(Plum value) plum,
    required TResult Function(Replay value) replay,
    required TResult Function(Seven value) seven,
    required TResult Function(Watermelon value) watermelon,
  }) {
    return replay(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bell value)? bell,
    TResult Function(Bar value)? bar,
    TResult Function(Cherry value)? cherry,
    TResult Function(Plum value)? plum,
    TResult Function(Replay value)? replay,
    TResult Function(Seven value)? seven,
    TResult Function(Watermelon value)? watermelon,
    required TResult orElse(),
  }) {
    if (replay != null) {
      return replay(this);
    }
    return orElse();
  }
}

abstract class Replay implements Symbol {
  const factory Replay() = _$Replay;
}

/// @nodoc
abstract class $SevenCopyWith<$Res> {
  factory $SevenCopyWith(Seven value, $Res Function(Seven) then) =
      _$SevenCopyWithImpl<$Res>;
}

/// @nodoc
class _$SevenCopyWithImpl<$Res> extends _$SymbolCopyWithImpl<$Res>
    implements $SevenCopyWith<$Res> {
  _$SevenCopyWithImpl(Seven _value, $Res Function(Seven) _then)
      : super(_value, (v) => _then(v as Seven));

  @override
  Seven get _value => super._value as Seven;
}

/// @nodoc

class _$Seven implements Seven {
  const _$Seven();

  @override
  String toString() {
    return 'Symbol.seven()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Seven);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() bell,
    required TResult Function() bar,
    required TResult Function() cherry,
    required TResult Function() plum,
    required TResult Function() replay,
    required TResult Function() seven,
    required TResult Function() watermelon,
  }) {
    return seven();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? bell,
    TResult Function()? bar,
    TResult Function()? cherry,
    TResult Function()? plum,
    TResult Function()? replay,
    TResult Function()? seven,
    TResult Function()? watermelon,
    required TResult orElse(),
  }) {
    if (seven != null) {
      return seven();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bell value) bell,
    required TResult Function(Bar value) bar,
    required TResult Function(Cherry value) cherry,
    required TResult Function(Plum value) plum,
    required TResult Function(Replay value) replay,
    required TResult Function(Seven value) seven,
    required TResult Function(Watermelon value) watermelon,
  }) {
    return seven(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bell value)? bell,
    TResult Function(Bar value)? bar,
    TResult Function(Cherry value)? cherry,
    TResult Function(Plum value)? plum,
    TResult Function(Replay value)? replay,
    TResult Function(Seven value)? seven,
    TResult Function(Watermelon value)? watermelon,
    required TResult orElse(),
  }) {
    if (seven != null) {
      return seven(this);
    }
    return orElse();
  }
}

abstract class Seven implements Symbol {
  const factory Seven() = _$Seven;
}

/// @nodoc
abstract class $WatermelonCopyWith<$Res> {
  factory $WatermelonCopyWith(
          Watermelon value, $Res Function(Watermelon) then) =
      _$WatermelonCopyWithImpl<$Res>;
}

/// @nodoc
class _$WatermelonCopyWithImpl<$Res> extends _$SymbolCopyWithImpl<$Res>
    implements $WatermelonCopyWith<$Res> {
  _$WatermelonCopyWithImpl(Watermelon _value, $Res Function(Watermelon) _then)
      : super(_value, (v) => _then(v as Watermelon));

  @override
  Watermelon get _value => super._value as Watermelon;
}

/// @nodoc

class _$Watermelon implements Watermelon {
  const _$Watermelon();

  @override
  String toString() {
    return 'Symbol.watermelon()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Watermelon);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() bell,
    required TResult Function() bar,
    required TResult Function() cherry,
    required TResult Function() plum,
    required TResult Function() replay,
    required TResult Function() seven,
    required TResult Function() watermelon,
  }) {
    return watermelon();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? bell,
    TResult Function()? bar,
    TResult Function()? cherry,
    TResult Function()? plum,
    TResult Function()? replay,
    TResult Function()? seven,
    TResult Function()? watermelon,
    required TResult orElse(),
  }) {
    if (watermelon != null) {
      return watermelon();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Bell value) bell,
    required TResult Function(Bar value) bar,
    required TResult Function(Cherry value) cherry,
    required TResult Function(Plum value) plum,
    required TResult Function(Replay value) replay,
    required TResult Function(Seven value) seven,
    required TResult Function(Watermelon value) watermelon,
  }) {
    return watermelon(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Bell value)? bell,
    TResult Function(Bar value)? bar,
    TResult Function(Cherry value)? cherry,
    TResult Function(Plum value)? plum,
    TResult Function(Replay value)? replay,
    TResult Function(Seven value)? seven,
    TResult Function(Watermelon value)? watermelon,
    required TResult orElse(),
  }) {
    if (watermelon != null) {
      return watermelon(this);
    }
    return orElse();
  }
}

abstract class Watermelon implements Symbol {
  const factory Watermelon() = _$Watermelon;
}
